{% macro attrib(key, prop, required) -%}
    {{ key }}: {{ prop|type_annotation }} = attrib(
        validator=[
            {{ prop|validators }}
        ],
        {% if prop|converter %}
        converter={{ prop|converter }},  # type: ignore
        {% endif %}
        {% if prop|default(key in required) %}
        default={{ prop|default(key in required) }},
        {% endif %}
    )
{%- endmacro %}
from typing import ClassVar, List, Type

from attr import attrs, attrib
# TODO: Import only what is needed.
# pylint: disable=wildcard-import,unused-wildcard-import
from jsonschema_objects.validators import *


NOT_PASSED = type(
    "NotPassed",
    tuple(),
    {"__repr__": lambda self: "<NOTPASSED>", "__bool__": lambda self: False}
)()


def instance_of(*types: Type):
    def validate_type(instance, attribute, value):
        # This callable acts as a method.
        # pylint: disable=protected-access
        if attribute.name not in instance._required and value == NOT_PASSED:
            return
        if not isinstance(value, types):
            raise TypeError(f"{attribute.name} must be type {types}, got {value}.")
    return validate_type


def instantiate(model: Type):
    def _convert(kwargs):
        return model(**kwargs)
    return _convert


def map_instantiate(model: Type):
    def _convert(list_kwargs):
        return [model(**kwargs) for kwargs in list_kwargs]
    return _convert
{% for schema in schemas %}


@attrs(kw_only=True)
class {{ schema.title }}:
    """{{ schema.description }}"""

    _required: ClassVar[List[str]] = {{ schema.required }}

{% for key, prop in schema.properties.items() %}
    {{ attrib(key, prop, schema.required) }}
{% endfor %}
{% endfor %}